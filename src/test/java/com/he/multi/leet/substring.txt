下面提供三种不同思路对应的 Java 代码示例，每个示例中都有详细的注释，帮助你理解各个步骤。

---

### 1. 动态规划（DP）方法

**思路说明：**
我们定义一个 dp 数组，其中 dp[i] 表示以 s[i] 结尾的不含重复字符的最长子串的长度。
同时用一个 Map 记录每个字符上一次出现的位置，根据与 dp[i-1] 的关系来更新 dp[i]。

```java
import java.util.HashMap;

public class LongestSubstringDP {

    /**
     * 使用动态规划求解最长不重复子串的长度
     * dp[i] 表示以 s[i] 结尾的不重复子串的长度
     */
    public static int lengthOfLongestSubstringDP(String s) {
        int n = s.length();
        if (n == 0) return 0;

        int[] dp = new int[n];            // dp[i] 表示以 s[i] 结尾的最长无重复子串长度
        dp[0] = 1;                        // 第一个字符的子串长度为1
        HashMap<Character, Integer> lastIndex = new HashMap<>();
        lastIndex.put(s.charAt(0), 0);
        int maxLen = 1;

        for (int i = 1; i < n; i++) {
            char c = s.charAt(i);
            // 如果字符 c 没出现过，则 dp[i] = dp[i-1] + 1
            if (!lastIndex.containsKey(c)) {
                dp[i] = dp[i - 1] + 1;
            } else {
                int prevIndex = lastIndex.get(c);
                // 如果当前字符上次出现距离 i 超过了 dp[i-1]，说明当前子串没有包含重复的 c
                if (i - prevIndex > dp[i - 1]) {
                    dp[i] = dp[i - 1] + 1;
                } else {
                    // 否则，最长子串只能从 prevIndex + 1 开始
                    dp[i] = i - prevIndex;
                }
            }
            // 更新当前字符的最后出现位置
            lastIndex.put(c, i);
            maxLen = Math.max(maxLen, dp[i]);
        }

        return maxLen;
    }

    public static void main(String[] args) {
        String s = "abcabcbb";
        System.out.println("动态规划方法 - 输入: " + s);
        System.out.println("输出: " + lengthOfLongestSubstringDP(s));  // 输出应为 3
    }
}
```

---

### 2. 固定大小数组的滑动窗口方法（适用于 ASCII 字符）

**思路说明：**
当字符集是有限（如 ASCII 码）时，可以用一个固定大小的数组记录每个字符上一次出现的索引。
这样可以避免 HashMap 带来的额外开销，实现更快的查找操作。

```java
import java.util.Arrays;

public class LongestSubstringFixedArray {

    /**
     * 使用固定大小数组记录字符最后出现的位置，求最长不重复子串的长度
     * 适用于 ASCII 字符，共 128 个字符
     */
    public static int lengthOfLongestSubstringFixed(String s) {
        int n = s.length();
        int[] last = new int[128];  // 用于存储字符最后出现的索引
        Arrays.fill(last, -1);      // 初始化为 -1，表示未出现过
        int maxLen = 0;
        int left = 0;               // 滑动窗口左边界

        for (int right = 0; right < n; right++) {
            char c = s.charAt(right);
            // 更新左边界，确保当前窗口内没有重复字符
            left = Math.max(left, last[c] + 1);
            // 计算当前窗口长度
            maxLen = Math.max(maxLen, right - left + 1);
            // 更新当前字符的最后出现位置
            last[c] = right;
        }
        return maxLen;
    }

    public static void main(String[] args) {
        String s = "abcabcbb";
        System.out.println("固定数组滑动窗口方法 - 输入: " + s);
        System.out.println("输出: " + lengthOfLongestSubstringFixed(s));  // 输出应为 3
    }
}
```

---

### 3. 双指针 + Set 方法

**思路说明：**
使用两个指针（left 和 right）构成一个窗口，并用一个 HashSet 保存窗口内的字符。
当遇到重复字符时，从左侧逐个移除字符，直到窗口内不含重复字符，再继续向右扩展。

```java
import java.util.HashSet;
import java.util.Set;

public class LongestSubstringSet {

    /**
     * 使用双指针和 HashSet 求最长无重复子串的长度
     */
    public static int lengthOfLongestSubstringSet(String s) {
        int n = s.length();
        Set<Character> set = new HashSet<>();
        int left = 0, right = 0;
        int maxLen = 0;

        // 右指针不断向右扩展窗口
        while (right < n) {
            char c = s.charAt(right);
            // 如果字符不在当前窗口内，则加入 set 并更新窗口长度
            if (!set.contains(c)) {
                set.add(c);
                right++;
                maxLen = Math.max(maxLen, set.size());
            } else {
                // 如果出现重复，则从左侧移除字符，缩小窗口
                set.remove(s.charAt(left));
                left++;
            }
        }
        return maxLen;
    }

    public static void main(String[] args) {
        String s = "abcabcbb";
        System.out.println("双指针+Set方法 - 输入: " + s);
        System.out.println("输出: " + lengthOfLongestSubstringSet(s));  // 输出应为 3
    }
}
```

---

### 总结

这三种方法在解决“最长无重复子串”问题时各有特点：

- **动态规划法**：利用状态转移关系，将问题分解为子问题，虽然与滑动窗口思想本质上类似，但用 dp 数组明确记录状态；
- **固定数组滑动窗口法**：当字符集有限时，使用数组替代 HashMap 可以提高效率；
- **双指针 + Set 方法**：概念直观，适合初学者理解滑动窗口的基本思想，但效率上略逊于固定数组方法。

你可以根据自己的理解和记忆习惯选择最适合你的方法，同时理解它们背后的核心思想，方便以后在类似问题上举一反三。